#pragma once
//  Copyright (c) 2021 DNV AS
//
//  Distributed under the Boost Software License, Version 1.0.
//  See accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt
#include "Reflection/Contents/IContent.h"
#include "Reflection/IExpressionEvaluator.h"

namespace DNVS {namespace MoFa { namespace Reflection { namespace Contents {
    /*
    ExpressionResult represents a subset of an expression, generated by using the EvaluateNextExpression command.
    Example:
    If we want to evaluate the expression "0 m 8m 5m", ExpressionResult for the first expression would hold:
    The start position in the string for this expression: 0,
    The end position in the string for this expression: 3,
    The object evaluated by this expression: Length(0) - represented by an Object.
    */
    struct ContentExpressionResult
    {
        ContentExpressionResult(const std::string& text, const std::shared_ptr<IContent>& content, size_t start, size_t end);
        ContentExpressionResult(const std::shared_ptr<IContent>& content, size_t startAndEnd);
        ContentExpressionResult();
        ContentExpressionResult(const std::string& text);
        ContentExpressionResult(const std::string& text, const Types::DecoratedTypeInfo& info, const IExpressionEvaluator& expressionEvaluator, size_t startIndex, size_t endIndex);
        bool IsValid() const;
        std::string GetString() const;
        size_t GetEndOfExpression() const;
        size_t GetStartOfExpression() const;
        std::shared_ptr<IContent> GetContent() const;
        void SetExpandedExpression(const std::string& expandedExpression);
        void AddOffset(size_t startOffset);
    private:
        size_t m_startOfExpression;
        size_t m_endOfExpression;
        std::shared_ptr<IContent> m_value;
        std::string m_expandedExpression;
    };

    ContentExpressionResult TryGenerateNextExpression(const std::string& text, const Types::DecoratedTypeInfo& info, const IExpressionEvaluator& expressionEvaluator, size_t startIndex, size_t index, const ContentExpressionResult& result);
    /*
    Returns true if the rest of the characters after startIndex are blank. Otherwise, returns false.
    */
    bool IsRemainderEmpty(const std::string& text, size_t startIndex);
    size_t FindNextNonSpace(const std::string& text, size_t index = 0);
}}}}
